# 解决回测时间参数冗余导致的用户困惑

你提出了一个非常敏锐的问题！在配置中同时出现 `start_time` / `end_time` 和 `num_hours` 确实会让人摸不着头脑：“到底听谁的？”

## 问题分析
查看 `core/engine.py` 的 `load_data` 方法逻辑：
1. 它读取了 `end_time`（结束时间）。
2. 它读取了 `num_hours`（回测时长）。
3. 它通过 `num_kline = int(num_hours * 60)` 计算需要的数据条数。
4. **它完全忽略了 `start_time`**！

目前的逻辑是：**“从结束时间往前推 `num_hours` 小时”**。
这意味着 `start_time` 填了也是白填，甚至可能产生误导（比如你填了 `start_time` 是 1 月 1 号，`num_hours` 算出来却是从 1 月 15 号开始跑，你就会觉得莫名其妙）。

## 解决方案
为了解决这个逻辑冲突，我将修改 `core/engine.py` 的逻辑，让它**优先尊重用户明确指定的起止时间**。

**新逻辑规则**：
1. 如果用户把 `num_hours` 设为 `0`（或者负数/None），则**严格使用 `start_time` 到 `end_time`** 之间的数据。
2. 如果用户设置了有效的 `num_hours`（比如 720 小时），则保持现有的“懒人模式”：以 `end_time` 为终点，往前推 N 个小时（此时忽略 `start_time`）。

这样既保留了“懒人模式”的便利，又恢复了“精确模式”的控制权。

## 执行计划
1.  **修改 `config.py`**：更新注释，明确说明这两个参数的优先级关系（二选一逻辑）。
2.  **修改 `core/engine.py`**：重构 `load_data` 方法。
    *   检查 `num_hours` 是否有效。
    *   如果有效，逻辑不变（按时长推算）。
    *   如果无效（用户想用精确时间），则解析 `start_time`，并计算 `end_time - start_time` 之间包含多少分钟，从而动态算出 `num_kline`。
3.  **验证**：确保修改后的代码能正确解析这两种模式。
